---
title: "Exploratory Data Analysis"
author: "Lea Collin"
date: "4/9/2019"
output:
  html_document:
    df_print: paged
---

```{r load_libraries, include = FALSE}
library(data.table)
library(tidyverse)
#library(extracat)#
library(lubridate)
library(choroplethr)
#library(choroplethrZip)#
library(Hmisc)
```

```{r load_data}
#setwd("~/Columbia/AppliedDS/FinalProject/AppliedDataScienceFinalProject")#
all.data <- fread("NYCRealEstateFullData.csv")
```

```{r functions}
avg.sale.price.by <- function(data, by.column.names){
  mean.price <- data[, .(`Avg. Price` = mean(get(sale.price.name), na.rm=TRUE)), by = by.column.names]
  return (mean.price)
}
graph.choropleth <- function(data, year){
  keep_cols = c(zip.name, sale.price.name)
  data(zip.regions)
  zip.prices <- data[get(sale.year.name) == year, ..keep_cols]
  zip.prices <- zip.prices[, mean(get(sale.price.name), na.rm = TRUE), by = zip.name]
  colnames(zip.prices) <- c("region", "value")
  zip.prices$value <- as.numeric(zip.prices$value)
  zip.prices$region <- as.character(zip.prices$region)
  zip.prices <- zip.prices[region %in% zip.regions$region,]
  zip.prices <- zip.prices[value > 0,]
  
  plot.title <- c(year, " Average Sale Price by Zip Code")
  plot.title <- paste(plot.title, collapse="")
  
  choro.graph <- zip_choropleth(zip.prices,
                 zip_zoom = zip.prices$region,
                 title       =  plot.title,
                 legend      = "Average Sale Price")
  return (choro.graph)
}
line.plot <- function(data, facet_variable = ''){
  if (facet_variable != ''){
    mean.price <- avg.sale.price.by(data = data, c(sale.year.name))
    setorderv(x = mean.price, cols = "Sale Year", order = 1)
    price.plot <- ggplot(mean.price, aes(`Sale Year`, as.integer(`Avg. Price`))) + 
                   geom_line(size = 1) + geom_point(aes(`Sale Year`,as.integer(`Avg. Price`))) +
                   xlab("Sale Year") + ylab("Avg. Price") +
                   scale_x_continuous(breaks = scales::pretty_breaks(length(mean.price$`Sale Year`))) +
                   ggtitle("NYC Avg. Real Estate Price by Year") 
    return (price.plot)
  }
  else{
    mean.price <- avg.sale.price.by(data, c(sale.year.name, facet_variable))
    setorderv(x = mean.price, cols = "Sale Year", order = 1)
    
    price.plot <- ggplot(mean.price, aes(`Sale Year`, as.integer(`Avg. Price`), color = facet_variable)) + 
                   geom_line(size = 1) + geom_point(aes(`Sale Year`,as.integer(`Avg. Price`))) +
                   xlab("Sale Year") + ylab("Avg. Price") + labs(color = facet_variable) +
                   scale_x_continuous(breaks = scales::pretty_breaks(length(mean.price$`Sale Year`))) +
                   ggtitle("NYC Avg. Real Estate Price by  and Year") 
    return (price.plot)
  }
  
}
```

```{r constants}
old.borough.name <- "BOROUGH"
borough.name <- "Fixed Borough"
neighborhood.name <- "NEIGHBORHOOD"
building.class.name <- "BUILDING CLASS CATEGORY"
tax.class.name <- "TAX CLASS AT PRESENT"
block.name <- "BLOCK"
lot.name <- "LOT"
easement.name <- "EASE-MENT"
building.class.present.name <- "BUILDING CLASS AT PRESENT"
address.name <- "ADDRESS"
apartment.number.name <- "APARTMENT NUMBER"
zip.name <- "ZIP CODE"
residential.name <- "RESIDENTIAL UNITS"
commercial.name <- "COMMERCIAL UNITS"
total.units.name <- "TOTAL UNITS"
land.square.feet.name <- "LAND SQUARE FEET"
gross.square.feet.name <- "GROSS SQUARE FEET"
year.built.name <- "YEAR BUILT"
tax.class.sale.name <- "TAX CLASS AT TIME OF SALE"
building.class.sale.name <- "BUILDING CLASS AT TIME OF SALE"
sale.price.name <- "SALE PRICE"
sale.date.name <- "SALE DATE"
sale.year.name <- "Sale Year"
log.price.name <- "Log Price"
sale.month<-"SALE MONTH"
sale.year<-"SALE YEAR"
building.class.first.letter <- "Building Class First Letter"
year.built.name <- "YEAR BUILT"
borough_name <- c("Manhattan", "Bronx", "Brooklyn", "Queens", "Staten Island")
residential.group.name <- "RESIDENTIAL UNITS GROUP"
commercial.group.name <- "COMMERCIAL UNITS GROUP"
total.units.group.name <- "TOTAL UNIT GROUP"
land.group.name <- "LAND SQUARE FEET GROUP"
gross.group.name <- "GROSS SQUARE FEET GROUP"
cuts.total <- c(0, 1, 2, 3, 5)
cuts.land <- c(0, 100, 1000, 2000, 3000)
all.data[, eval(total.units.group.name) := cut2(x = get(total.units.name), cuts = cuts.total)]
all.data[, eval(land.group.name) := cut2(x = get(land.square.feet.name), cuts = cuts.land)]
unique.total.units.group <- all.data[, unique(get(total.units.group.name))]
unique.land.group <- all.data[, unique(get(land.group.name))]
scaled.price.name <- "Scaled Price"
scaled.total.units <- "Scaled Total Units"
all.data[, eval(scaled.price.name) := scale(x = get(sale.price.name))]
all.data[, eval(scaled.total.units) := scale(x = get(total.units.name))]
all.data[, `Log Price` := log(get(sale.price.name))]
```



```{r, fig.height = 20}
colSums(is.na(all.data))
```

We see that the most common columns that have missing values are "EASE.MENT" and "APARTMENT NUMBER". Both of these have missing values in more than half of all rows. It is probably safe to get rid of these columns and ignore them both in our exploratory analysis and our machine learning model as they likely do not hold any valuable information with so many missing values. It may have been interesting to look at apartment number, to see how the floor of the apartment (ie floor in the building) affects the apartments price. Otherwise the only other missing valued columns are "TAX CLASS AT PRESENT", "BUILDING CLASS AT PRESENT", "BUILDING CLASS CATEGORY", and "ADDRESS". Address has only 7 missing values in over 1.4 million rows and there are many other columns that indicate the location of these buildings. What is interesting is that whenever Tax Class at Present is missing, so is Building Class at Present. These have the next highest number of missing values, but still only have about 20,000 NA which is not much when compared to the number of rows. 

```{r fix_na}
all.data$`EASE-MENT` <- NULL
all.data$`APARTMENT NUMBER` <- NULL
```

```{r sale_price}
all.data[get(sale.price.name) == 0, .N]
all.data[get(sale.price.name) < 50000, .N]
```

While looking at the data when we were choosing a dataset, we noticed that some sales prices are listed as 0. The documentation for the data claims:

A \$0 sale indicates that there was a transfer of ownership without a cash consideration. There can be a number of reasons for a $0 sale including transfers of ownership from parents to children. 

It may be interesting to look at what kinds of properties are most common in transfers of ownership with no cash consideration, especially since they make up almost a third of our dataset. Furthermore, there are other "weird" values. Such as values of 1 or 10. We'll take a closer look at the types of buildings that list these as their sale price. For now, we will only look at data that has a price of more than 50,000 and continue with our analysis.

```{r no_zero_sales}
# also taking the log for future graphing
all.data[, `Log Price` := log(get(sale.price.name))]
all.data[, `Sale Year` := year(get(sale.date.name))]
all.data[, `Building Class First Letter` := substr(get(building.class.sale.name), 1, 1)]
dat <- all.data[get(sale.price.name) > 50000]
```

```{r avg_sale_price_by_year}
mean.year.price <- avg.sale.price.by(dat, c(sale.year.name))
setorderv(x = mean.year.price, cols = "Sale Year", order = 1)
year.price.plot <- ggplot(mean.year.price, aes(`Sale Year`, as.integer(`Avg. Price`))) + 
                   geom_line(size = 1) + geom_point(aes(`Sale Year`,as.integer(`Avg. Price`))) +
                   xlab("Sale Year") + ylab("Avg. Price") +
                   scale_x_continuous(breaks = scales::pretty_breaks(length(mean.year.price$`Sale Year`))) +
                   ggtitle("NYC Avg. Real Estate Price by Year") 
year.price.plot
```

Though this plot isn't terribly exciting, we do see a huge dip in price from 2007 to 2009, most likely due to the 2008 financial/housing crisis. We could also control these prices for inflation since they are taking into account data over a 14 year range. (will try and do this later)

Let's look at the trends over the years, but now also by borough. 



Not too surprisingly, Manhattan sales prices are the highest among the five boroughs. In recent years, we have seen Brooklyn becoming a more sought-after neighborhood which has led to increases in higher real estate prices, as corroborated by this graph. We should note that since this dataset does not only include apartment buildings, that that is probably also the reason that we see such high real estate prices in Manhattan. Manhattan has many more large buildings than, say, Staten Island which is much more residential. What is also interesting to note is that the Manhattan line follows basically the same trend as the overall city trend, likely indicating that most of the data we have is from Manhattan. Finally, for all five boroughs, we see the same decline ine prices from 2007 to 2009 as we did in the overall city trend, though no decline is as noticeable as the one seen in Manhattan.

We could have also chosen to split this line graph by the building class type. We saw that the building class can be in a "broader" category based on the first letter in the class code. 

```{r need_to_reorganize}
dat <- all.data[get(sale.price.name) > 50000]
residential.codes <- c("A", "B", "C", "D", "RR", "R1", "R2", "R3", "R4", "R6", "R7", "R8", "R9")
residential.properties <- dat[get(building.class.first.letter) %in% residential.codes,]
```

```{r avg_sale_price_code}
mean.year.code.price <- avg.sale.price.by(residential.properties, c(sale.year.name, building.class.first.letter))
setorderv(x = mean.year.code.price, cols = "Sale Year", order = 1)
mean.year.code.price <- mean.year.code.price %>% mutate(`Building Class First Letter` = forcats::fct_reorder2(`Building Class First Letter`, `Sale Year`, `Avg. Price`)) # for coloring
year.code.price.plot <- ggplot(mean.year.code.price, aes(`Sale Year`, as.integer(`Avg. Price`), color = `Building Class First Letter`)) + 
                   geom_line(size = 1) + geom_point(aes(`Sale Year`,as.integer(`Avg. Price`))) +
                   xlab("Sale Year") + ylab("Avg. Price") + labs(color = "Building Class") +
                   scale_x_continuous(breaks = scales::pretty_breaks(length(unique(mean.year.code.price$`Sale Year`)))) +
                   ggtitle("NYC Avg.Residential Real Estate Price by Class Code and Year") 
year.code.price.plot
```

## Need to reorganize with things mentioned further down

We see that the ranking by price remains pretty consistent throughout the 14 year range. "A" type buildings are consistently the buildings with the lowest average price whereas "C" and "D" class buildings are consistetly much higher priced. All of the "D" buildings are elevator buildings which could explain why they are more expensive. Additionally, the "D" class buildings have "luxury apartments" which could be bumping up the average price.

Now we will look at the distribution of each borough's sale prices over the years. For this static report, we will focus only on 2003 and 2017 and look at the distribution for each borough. In our Shiny application, we will give the user a chance to look at each year, however, this is just too much variable information to show in a static report.

```{r boxplot_borough}
box.borough.2017 <- dat[get(sale.year.name) == 2017]
box.borough.2017$`Sale Year` <- as.factor(box.borough.2017$`Sale Year`)
box.borough.2017.plot <- ggplot(box.borough.2017, aes(x = reorder(`Fixed Borough`, -1*`Log Price`, FUN=median), y = `Log Price`)) +
                    geom_boxplot() +
                    xlab("Borough") + ylab("Log Sale Price") + ggtitle("2017 by Borough") +
                    theme(plot.title = element_text(hjust = 0.5))
box.borough.2017.plot
box.borough.2003 <- dat[get(sale.year.name) == 2003]
box.borough.2003$`Sale Year` <- as.factor(box.borough.2003$`Sale Year`)
box.borough.2003.plot <- ggplot(box.borough.2003, aes(x = reorder(`Fixed Borough`, -1*`Log Price`, FUN=median), y = `Log Price`)) +
                    geom_boxplot() +
                    xlab("Borough") + ylab("Log Sale Price") + ggtitle("2003 by Borough") +
                    theme(plot.title = element_text(hjust = 0.5))
box.borough.2003.plot
```

```{r choropleth_map}
#graph.choropleth(dat, 2017)#
```

As we can see, the range of values for sale price is enormous. Some areas have buildings with an average price of $2.2 billion! This is because the dataset includes any sale of property. Some properties are one-family homes or walk-up apartments while others are office buildings or retail buildings. The most expensive buildings that are likely office spaces can be found in Downtown or Midtown Manhattan. This makes sense as this is where the corporate side of New York resides.  

We can look at the distribution of the data furthermore by building class code. The class codes can be found here: https://www1.nyc.gov/assets/finance/jump/hlpbldgcode.html. The building class at present and building class at time of sale use these building class codes. First, let's take a look at how many rows there are where these codes are not the same. 

```{r unequal_class_code_num}
all.data[get(building.class.present.name) != get(building.class.sale.name), .N]
```

There are `r all.data[get(building.class.present.name) != get(building.class.sale.name), .N]` rows where the building class at present and the building class at time of sale are not the same. For the purposes of visualization and subsetting, we will use the building class at time of sale since we care about the sale price of the property. Now, similar builidng types start with the same letter. For example, building class codes starting with A are one-family homes whereas building class codes starting with B are two-family homes. This means that we can create a new column that is simply the first letter of the building class at the time of sale and this will help us subset our data for visualizations. Based on the documentation, the residential building codes start with: A, B, C, D, and some R. The R codes that don't seem residential are: RA, RB, RG, RH, RK, RP, RS, RT, R0, and R5. Below, we make another data.table with only the residential building class codes at time of sale. 

```{r building_code}
dat <- all.data[get(sale.price.name) > 50000]
residential.codes <- c("A", "B", "C", "D", "RR", "R1", "R2", "R3", "R4", "R6", "R7", "R8", "R9")
residential.properties <- dat[get(building.class.first.letter) %in% residential.codes,]
```


## Gengyu Zhang


Now we are looking at how the unit and the area may affect the price. Without loss of generality, we will mainly focus on total units and land square feet here (and in fact the `total units` is just the sum of the residential units and commercial). We first make the scatter plot of price against these two variables. From these graphs we can find a few data seem like outliers. Also, most of the data concentrate on the left bottom. Therefore we then make the scatter plot on a subset and again we cannot find obvious correlation among these variables. Later we will calculate the correlation and fit linear regression models to check them. Now to make it clearer in visualization we decide to cut these variables into groups because of the discontinuity of the variables, then we can make bar plot like borough and building class.

## Correlation Between Price and Land Square Feet

```{r scatter_unit_square.feet_1, echo = FALSE, cache = TRUE}
ggplot(data = dat) +
  geom_point(mapping = aes(x = get(total.units.name), y = get(scaled.price.name))) +
  labs(title = "Scaled NYC Real Estate Price by Total Units", x = "Total Units", y = "Scaled Sale Price")
ggplot(data = dat) +
  geom_point(mapping = aes(x = get(land.square.feet.name), y = get(scaled.price.name))) +
  labs(title = "Scaled NYC Real Estate Price by Land Square feet", x = "Land Square Feet", y = "Scaled Sale Price")
```

## Correlation on a Subset

```{r scatter_unit_square.feet_2, echo = FALSE, cache = TRUE}
sub.data.unit.feet <- all.data[get(total.units.name) > 0 & get(total.units.name) < 5000 & get(land.square.feet.name) > 0 & get(land.square.feet.name) < 50000000 & get(sale.price.name) > 50000 & get(sale.price.name) < 5000000, ]
ggplot(data = sub.data.unit.feet) +
  geom_point(mapping = aes(x = get(total.units.name), y = get(scaled.price.name))) +
  labs(title = "Scaled NYC Real Estate Price by Total Units", x = "Total Units", y = "Scaled Sale Price")
ggplot(data = sub.data.unit.feet) +
  geom_point(mapping = aes(x = get(land.square.feet.name), y = get(scaled.price.name))) +
  labs(title = "Scaled NYC Real Estate Price by Land Square feet", x = "Land Square Feet", y = "Scaled Sale Price")
```


One interesting thing here is that most of the properties have total units lower than 5; however the bar plot tells us that the difference in price are mainly reflected in the group of total units higher than 5. Another interesting finding is that there is an obvious gap between the first group and the third when we are considering the land square. It may because that the properties can roughly divided into those smaller ones that are residential and larger ones that are commercial. Then it comes to our mind that it may be reasonable to split the data into two big groups. However, the price don¡¯t seem to be increasing when the land square feet increasing, as what we have expected. Compared with the difference among those groups, the differences within each group seem even bigger. 

## Binning Total Units and Land Square Feet 

```{r barplot_unit_square.feet_num, echo = FALSE, warning = FALSE}
unit.Num <- dat[, .N, by = total.units.group.name]
ggplot(data = unit.Num, mapping = aes(x = get(total.units.group.name), y = N)) +
  geom_bar(stat = "identity", color = "blue", fill = "#99CCFF") +
  labs(x = "Group of Total Units", y = "Number of Cases in each Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
land.Num <- dat[, .N, by = land.group.name]
ggplot(data = land.Num, mapping = aes(x = get(land.group.name), y = N)) +
  geom_bar(stat = "identity", color = "blue", fill = "#99CCFF") + 
  labs(x = "Group of Land Square Feet", y = "Number of Cases in each Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Inspecting Logarithm of Price

```{r boxplot_unit_square.feet_price, warning = FALSE}
ggplot(data = dat, aes(x = get(total.units.group.name), y = get(log.price.name))) +
  geom_boxplot() +
  labs(title = "Logarithm of NYC Real Estate Price by Total Units", x = "Group of Total Units", y = "Log Sale Price") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(data = dat, aes(x = get(land.group.name), y = get(log.price.name))) +
  geom_boxplot() +
  labs(title = "Logarithm of NYC Real Estate Price by Land Square Feet", x = "Group of Land Square Feet", y = "Log Sale Price") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Next we will look at another important variable, tax class. To make it clearer and more meaningful, we will discuss the `Tax class at time of sale` instead of `Tax class at present`, as there are only four different classes at time of sale.

## Tax class

```{r}
text.sale.borough <- dat[, .N, by = c(tax.class.sale.name, borough.name)]

ggplot(data = text.sale.borough, mapping = aes(x = as.factor(get(tax.class.sale.name)), y = N)) +
  geom_bar(stat = "identity", color = "blue", fill = "#99CCFF") +
  labs(x = "Tax Class at time of sale", y = "Number of Cases in each Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_grid(`Fixed Borough` ~ . )
```

This is the bar plot of the breakdown of the tax class across the borough. The most noteworthy feature is that there are far less properties with tax class 1 in Manhattan and properties with tax class 2 in Staten Island. Conversely, there are obviously more properties with tax class 2 in Manhattan. Considering tax class 1 refers to those small residential properties and tax class 2 refers to those properties including cooperatives and condominiums, it is no surprise that the amount of these tax classes differ greatly from Manhattan and Staten Island.

Then from the bar plot considering the price, we find no obvious difference among these tax classes. However, there are far more properties have higher price than average in tax class 2. Remind of the differences across the borough, it seems that those properties with high prices in tax class 2 decide the higher average price in Manhattan. There is even a probability that the factor affecting real estate prices may be due to the tax class, instead of ¡°Manhattan¡±. The influence of the tax class may be further studied in our models.

```{r}
ggplot(data = dat, aes(x = as.factor(get(tax.class.sale.name)), y = get(log.price.name))) +
  geom_boxplot() +
  labs(title = "Logarithm of NYC Real Estate Price by Tax Class", x = "Tax class at time of sale", y = "Log Sale Price") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Then from the bar plot considering the price, we find no obvious difference among these tax classes. However, there are far more properties have higher price than average in tax class 2. Remind of the differences across the borough, it seems that those properties with high prices in tax class 2 decide the higher average price in Manhattan. There is even a probability that the factor affecting real estate prices may be due to the tax class, instead of ¡°Manhattan¡±. The influence of the tax class may be further studied in our models.